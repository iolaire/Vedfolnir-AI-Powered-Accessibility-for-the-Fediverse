# Redis Session Management Architecture

## Overview

Vedfolnir uses Redis as the primary session storage backend with Flask session cookies for session identification. This architecture provides high performance, scalability, and reliability for session management across the application.

## Architecture Components

### 1. Session Storage Layer
- **Primary Storage**: Redis in-memory database
- **Session Identification**: Flask session cookies containing unique session IDs
- **Session Retrieval**: Session IDs used as keys to retrieve session data from Redis
- **Fallback Storage**: Database backup for audit trails and recovery scenarios

### 2. Session Cookie Management
- **Cookie Type**: HTTP-only, secure session cookies managed by Flask
- **Session ID**: Unique identifier generated by Flask's session management
- **Security**: Proper SameSite configuration, secure flag for HTTPS
- **Expiration**: Configurable session timeout with automatic cleanup

### 3. Redis Configuration
```bash
# Redis Connection
REDIS_URL=redis://localhost:6379/0
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
REDIS_PASSWORD=  # Optional
REDIS_SSL=false

# Session Settings
REDIS_SESSION_PREFIX=vedfolnir:session:
REDIS_SESSION_TIMEOUT=7200  # 2 hours
REDIS_SESSION_CLEANUP_INTERVAL=3600  # 1 hour
```

### 4. Flask Session Cookie Configuration
```bash
# Cookie Security
SESSION_COOKIE_NAME=session
SESSION_COOKIE_HTTPONLY=true
SESSION_COOKIE_SECURE=true  # false for development
SESSION_COOKIE_SAMESITE=Lax
SESSION_COOKIE_MAX_AGE=7200
```

## Session Lifecycle

### 1. Session Creation
1. User authenticates through the web interface
2. Flask generates a unique session ID
3. Session data is stored in Redis with the session ID as key
4. Session cookie containing the session ID is sent to the browser
5. Database audit record is created for session tracking

### 2. Session Access
1. Browser sends session cookie with each request
2. Flask extracts session ID from the cookie
3. Application queries Redis using the session ID
4. Session data is retrieved and made available to the request
5. Session activity is logged for audit purposes

### 3. Session Updates
1. Application modifies session data during request processing
2. Updated session data is stored back to Redis
3. Session expiration time is refreshed
4. Database audit trail is updated if needed

### 4. Session Cleanup
1. Automatic cleanup runs at configured intervals
2. Expired sessions are removed from Redis
3. Database audit records are maintained for retention period
4. Cross-tab synchronization events are cleaned up

## Key Benefits

### Performance
- **Sub-millisecond Access**: Redis provides extremely fast session retrieval
- **Memory Efficiency**: Optimized memory usage with automatic expiration
- **Reduced Database Load**: Sessions don't impact database performance

### Scalability
- **Horizontal Scaling**: Multiple application instances can share Redis
- **High Concurrency**: Redis handles thousands of concurrent sessions
- **Load Distribution**: Session data is independent of application server

### Reliability
- **Database Fallback**: Critical session data backed up to database
- **Automatic Recovery**: Sessions can be restored from database if needed
- **Graceful Degradation**: Application continues working if Redis is unavailable

### Security
- **Server-Side Storage**: Session data never exposed to client
- **Secure Cookies**: HTTP-only cookies prevent XSS attacks
- **Session Validation**: Built-in session fingerprinting and validation
- **Audit Trail**: Complete session activity logging

## Implementation Details

### RedisSessionManager
- Primary session management class
- Handles all Redis operations
- Provides session CRUD operations
- Manages session expiration and cleanup

### Session Cookie Manager
- Flask integration for cookie handling
- Secure cookie configuration
- Session ID generation and validation
- Cookie security headers

### Database Fallback
- Audit trail maintenance
- Session recovery capabilities
- Long-term session analytics
- Compliance and security logging

## Migration Considerations

### From Database Sessions
1. Existing database sessions continue to work
2. New sessions are created in Redis
3. Gradual migration as sessions expire
4. No user impact during transition

### Redis Deployment
1. Install and configure Redis server
2. Update environment configuration
3. Test Redis connectivity
4. Monitor session performance

## Monitoring and Maintenance

### Key Metrics
- Session creation rate
- Session access latency
- Redis memory usage
- Session cleanup efficiency
- Database fallback usage

### Health Checks
- Redis connectivity monitoring
- Session data integrity checks
- Performance threshold monitoring
- Automatic alerting for issues

### Maintenance Tasks
- Regular Redis memory optimization
- Session cleanup monitoring
- Database audit log rotation
- Performance tuning adjustments

## Development Guidelines

### Session Access Patterns
```python
# Accessing session data
from flask import session
user_id = session.get('user_id')
platform_id = session.get('current_platform_id')

# Updating session data
session['last_activity'] = datetime.utcnow()
session['current_platform_id'] = new_platform_id
```

### Redis Direct Access (Advanced)
```python
# Direct Redis operations (when needed)
from redis_session_manager import RedisSessionManager
session_manager = RedisSessionManager(db_manager, config.redis)
session_data = session_manager.get_session_data(session_id)
```

### Testing Considerations
- Mock Redis for unit tests
- Integration tests with real Redis
- Session lifecycle testing
- Performance benchmarking
- Failover scenario testing

## Security Considerations

### Session Security
- Regular session rotation
- Suspicious activity detection
- Session fingerprinting
- Concurrent session limits
- Geographic anomaly detection

### Data Protection
- Session data encryption in Redis
- Secure key management
- Access logging and monitoring
- Compliance with data protection regulations

### Attack Prevention
- Session fixation protection
- Cross-site request forgery (CSRF) protection
- Session hijacking prevention
- Brute force attack mitigation

## Troubleshooting

### Common Issues
1. **Redis Connection Failures**: Check Redis server status and network connectivity
2. **Session Loss**: Verify Redis persistence configuration and memory limits
3. **Performance Issues**: Monitor Redis memory usage and connection pool settings
4. **Cookie Problems**: Check secure flag settings for HTTP vs HTTPS environments

### Debugging Tools
- Redis CLI for direct session inspection
- Session monitoring dashboard
- Performance profiling tools
- Audit log analysis

### Recovery Procedures
- Database session fallback activation
- Redis data recovery from persistence
- Session migration procedures
- Emergency session cleanup
