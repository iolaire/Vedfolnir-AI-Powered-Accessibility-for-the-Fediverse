<!-- Copyright (C) 2025 iolaire mcfadden. -->
<!-- This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. -->
<!-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. -->

{% extends "base_admin.html" %}

{% block title %}Performance Dashboard - Admin{% endblock %}

{% block extra_head %}
<style>
.performance-dashboard {
    padding: 20px;
}

.stat-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 10px;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.stat-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    margin: 20px 0 30px 0;
    padding: 0 15px;
}

.metric-card {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    border-left: 4px solid #007bff;
    text-align: center;
    min-height: 120px;
    display: flex;
    flex-direction: column;
    justify-content: center;
}

.metric-card.warning {
    border-left-color: #ffc107;
}

.metric-card.critical {
    border-left-color: #dc3545;
}

.metric-value {
    font-size: 2em;
    font-weight: bold;
    color: #333;
}

.metric-label {
    color: #666;
    font-size: 0.9em;
    margin-top: 5px;
}

.metric-trend {
    font-size: 0.8em;
    margin-top: 5px;
}

.trend-up {
    color: #28a745;
}

.trend-down {
    color: #dc3545;
}

.trend-stable {
    color: #6c757d;
}

.health-status {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 20px;
}

.status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
}

.status-healthy {
    background-color: #28a745;
}

.status-warning {
    background-color: #ffc107;
}

.status-critical {
    background-color: #dc3545;
}

.recommendations-panel {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.recommendation-item {
    border: 1px solid #e9ecef;
    border-radius: 4px;
    padding: 15px;
    margin-bottom: 10px;
}

.recommendation-item.high-priority {
    border-left: 4px solid #dc3545;
}

.recommendation-item.medium-priority {
    border-left: 4px solid #ffc107;
}

.recommendation-item.low-priority {
    border-left: 4px solid #28a745;
}

.chart-container {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 20px;
    height: 400px;
    position: relative;
    overflow: hidden;
}

.chart-container canvas {
    max-height: 350px !important;
    max-width: 100% !important;
    width: 100% !important;
    height: 350px !important;
    position: absolute;
    top: 50px;
    left: 20px;
    right: 20px;
}

.loading {
    text-align: center;
    padding: 20px;
    color: #666;
}

.error {
    color: #dc3545;
    background: #f8d7da;
    border: 1px solid #f5c6cb;
    border-radius: 4px;
    padding: 10px;
    margin: 10px 0;
}

.btn-optimize {
    background-color: #007bff;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
}

.btn-optimize:hover {
    background-color: #0056b3;
}

.btn-optimize:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
}

.refresh-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.auto-refresh {
    display: flex;
    align-items: center;
    gap: 10px;
}
</style>
{% endblock %}

{% block content %}
<div class="performance-dashboard">
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h1>Performance Dashboard</h1>
        <div class="refresh-controls">
            <div class="auto-refresh">
                <label>
                    <input type="checkbox" id="autoRefresh" checked> Auto-refresh (30s)
                </label>
                <button class="btn btn-primary btn-sm" onclick="refreshDashboard()">Refresh Now</button>
            </div>
        </div>
    </div>

    <!-- System Health Status -->
    <div class="health-status" id="systemHealth">
        <div class="status-indicator status-healthy"></div>
        <span>Loading system health...</span>
    </div>

    <!-- Performance Metrics Grid -->
    <div class="row mb-4" id="metricsGrid">
        <div class="col-md-2">
            <div class="card stat-card text-white">
                <div class="card-body text-center">
                    <i class="bi bi-speedometer2" style="font-size: 2rem;"></i>
                    <h3 class="mt-2" id="throughputValue">--</h3>
                    <p class="mb-0">Messages/Second</p>
                    <small>Throughput</small>
                </div>
            </div>
        </div>
        
        <div class="col-md-2">
            <div class="card stat-card text-white">
                <div class="card-body text-center">
                    <i class="bi bi-diagram-3" style="font-size: 2rem;"></i>
                    <h3 class="mt-2" id="connectionsValue">--</h3>
                    <p class="mb-0">WebSocket Connections</p>
                    <small>Active</small>
                </div>
            </div>
        </div>
        
        <div class="col-md-2">
            <div class="card stat-card text-white">
                <div class="card-body text-center">
                    <i class="bi bi-lightning" style="font-size: 2rem;"></i>
                    <h3 class="mt-2" id="cacheHitRateValue">--</h3>
                    <p class="mb-0">Cache Hit Rate</p>
                    <small>Performance</small>
                </div>
            </div>
        </div>
        
        <div class="col-md-2">
            <div class="card stat-card text-white">
                <div class="card-body text-center">
                    <i class="bi bi-memory" style="font-size: 2rem;"></i>
                    <h3 class="mt-2" id="memoryUsageValue">--</h3>
                    <p class="mb-0">Memory (MB)</p>
                    <small>Usage</small>
                </div>
            </div>
        </div>
        
        <div class="col-md-2">
            <div class="card stat-card text-white">
                <div class="card-body text-center">
                    <i class="bi bi-cpu" style="font-size: 2rem;"></i>
                    <h3 class="mt-2" id="cpuUsageValue">--</h3>
                    <p class="mb-0">CPU Usage</p>
                    <small>System Load</small>
                </div>
            </div>
        </div>
        
        <div class="col-md-2">
            <div class="card stat-card text-white">
                <div class="card-body text-center">
                    <i class="bi bi-database" style="font-size: 2rem;"></i>
                    <h3 class="mt-2" id="dbQueryTimeValue">--</h3>
                    <p class="mb-0">DB Query (ms)</p>
                    <small>Response Time</small>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance Charts -->
    <div class="row">
        <div class="col-md-6">
            <div class="chart-container">
                <h5>Throughput Trend</h5>
                <canvas id="throughputChart"></canvas>
            </div>
        </div>
        <div class="col-md-6">
            <div class="chart-container">
                <h5>Resource Usage</h5>
                <canvas id="resourceChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Optimization Recommendations -->
    <div class="recommendations-panel">
        <h5>Optimization Recommendations</h5>
        <div id="recommendationsContainer">
            <div class="loading">Loading recommendations...</div>
        </div>
    </div>

    <!-- Detailed Reports -->
    <div class="row">
        <div class="col-md-4">
            <div class="card">
                <div class="card-header">
                    <h6>Connection Pool Status</h6>
                </div>
                <div class="card-body" id="connectionPoolStatus">
                    <div class="text-muted">Connection pool data will appear here</div>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card">
                <div class="card-header">
                    <h6>Cache Statistics</h6>
                </div>
                <div class="card-body" id="cacheStatistics">
                    <div class="text-muted">Cache statistics will appear here</div>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card">
                <div class="card-header">
                    <h6>Database Performance</h6>
                </div>
                <div class="card-body" id="databasePerformance">
                    <div class="text-muted">Database performance data will appear here</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Chart.js for performance charts -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>

<script>
let throughputChart = null;
let resourceChart = null;
let autoRefreshInterval = null;

// Chart.js plugin for "No Data" text
const noDataPlugin = {
    id: 'noDataText',
    afterDraw: function(chart) {
        if (chart.data.datasets[0].data.length === 0) {
            const ctx = chart.ctx;
            const width = chart.width;
            const height = chart.height;
            
            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '16px Arial';
            ctx.fillStyle = '#999';
            ctx.fillText('No History Yet', width / 2, height / 2);
            ctx.restore();
        }
    }
};

Chart.register(noDataPlugin);

async function refreshDashboard() {
    try {
        await Promise.all([
            loadCurrentMetrics(),
            loadSystemHealth(),
            loadRecommendations(),
            loadPerformanceTrends()
        ]);
    } catch (error) {
        console.error('Error refreshing dashboard:', error);
        showError('Failed to refresh dashboard data');
    }
}

function setupAutoRefresh() {
    const autoRefreshCheckbox = document.getElementById('autoRefresh');
    
    function updateAutoRefresh() {
        if (autoRefreshCheckbox.checked) {
            autoRefreshInterval = setInterval(refreshDashboard, 30000); // 30 seconds
        } else {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }
    }
    
    // Enable auto-refresh by default
    autoRefreshCheckbox.checked = true;
    
    autoRefreshCheckbox.addEventListener('change', updateAutoRefresh);
    updateAutoRefresh(); // Initial setup
}

function showError(message) {
    console.error(message);
    alert('Error: ' + message);
}

function showSuccess(message) {
    console.log(message);
    alert('Success: ' + message);
}

async function loadCurrentMetrics() {
    try {
        console.log('Loading current metrics...');
        const response = await fetch('/admin/api/performance/metrics');
        console.log('Metrics response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const metrics = await response.json();
        console.log('Received metrics:', metrics);
        
        updateMetricsDisplay(metrics);
    } catch (error) {
        console.error('Failed to load current metrics:', error);
        updateMetricsDisplay({
            notification_throughput: 0,
            websocket_connections: 0,
            cache_hit_rate: 0,
            memory_usage_mb: 0,
            cpu_usage_percent: 0,
            database_query_time: 0
        });
    }
}

async function loadSystemHealth() {
    try {
        console.log('Loading system health...');
        const response = await fetch('/admin/api/performance/health');
        console.log('Health response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const health = await response.json();
        console.log('Received health:', health);
        
        updateHealthDisplay(health);
    } catch (error) {
        console.error('Failed to load system health:', error);
        const healthElement = document.getElementById('systemHealth');
        if (healthElement) {
            healthElement.innerHTML = '<div class="status-indicator status-error"></div><span>Health data unavailable</span>';
        }
    }
}

async function loadRecommendations() {
    try {
        console.log('Loading recommendations...');
        const response = await fetch('/admin/api/performance/recommendations');
        console.log('Recommendations response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('Received recommendations:', data);
        
        updateRecommendationsDisplay(data.recommendations || []);
    } catch (error) {
        console.error('Failed to load recommendations:', error);
        const container = document.getElementById('recommendationsContainer');
        if (container) {
            container.innerHTML = '<div class="text-muted">Recommendations unavailable</div>';
        }
    }
}

async function loadPerformanceTrends() {
    console.log('Loading performance trends...');
    // Placeholder for trends loading
}

// Initialize dashboard
document.addEventListener('DOMContentLoaded', function() {
    // Initialize charts first
    setTimeout(() => {
        initializeCharts();
    }, 100);
    
    // Load data after a longer delay to ensure everything is ready
    setTimeout(() => {
        console.log('Starting dashboard data load...');
        refreshDashboard();
    }, 1000);
    
    setupAutoRefresh();
});

function initializeCharts() {
    // Throughput chart
    const throughputCtx = document.getElementById('throughputChart').getContext('2d');
    throughputChart = new Chart(throughputCtx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [{
                label: 'Messages/Second',
                data: [],
                borderColor: '#007bff',
                backgroundColor: 'rgba(0, 123, 255, 0.1)',
                tension: 0.4
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true
                }
            },
            onResize: function(chart, size) {
                chart.canvas.style.height = '350px';
                chart.canvas.style.maxHeight = '350px';
            }
        }
    });

    // Resource usage chart
    const resourceCtx = document.getElementById('resourceChart').getContext('2d');
    resourceChart = new Chart(resourceCtx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Memory (MB)',
                    data: [],
                    borderColor: '#28a745',
                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                    tension: 0.4,
                    yAxisID: 'y'
                },
                {
                    label: 'CPU (%)',
                    data: [],
                    borderColor: '#dc3545',
                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                    tension: 0.4,
                    yAxisID: 'y1'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: {
                        display: true,
                        text: 'Memory (MB)'
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: {
                        display: true,
                        text: 'CPU (%)'
                    },
                    grid: {
                        drawOnChartArea: false,
                    },
                }
            },
            onResize: function(chart, size) {
                chart.canvas.style.height = '350px';
                chart.canvas.style.maxHeight = '350px';
            }
        }
    });
    
    // Force initial resize to ensure proper sizing
    setTimeout(() => {
        if (throughputChart) {
            throughputChart.canvas.style.height = '350px';
            throughputChart.canvas.style.maxHeight = '350px';
            throughputChart.canvas.height = 350;
            throughputChart.resize();
            throughputChart.update('none');
        }
        if (resourceChart) {
            resourceChart.canvas.style.height = '350px';
            resourceChart.canvas.style.maxHeight = '350px';
            resourceChart.canvas.height = 350;
            resourceChart.resize();
            resourceChart.update('none');
        }
    }, 100);

async function loadCurrentMetrics() {
    try {
        console.log('Loading current metrics...');
        const response = await fetch('/admin/api/performance/metrics');
        console.log('Metrics response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const metrics = await response.json();
        console.log('Received metrics:', metrics);
        
        updateMetricsDisplay(metrics);
    } catch (error) {
        console.error('Failed to load current metrics:', error);
        // Show fallback data instead of failing completely
        updateMetricsDisplay({
            notification_throughput: 0,
            websocket_connections: 0,
            cache_hit_rate: 0,
            memory_usage_mb: 0,
            cpu_usage_percent: 0,
            database_query_time: 0
        });
    }
}

async function loadSystemHealth() {
    try {
        console.log('Loading system health...');
        const response = await fetch('/admin/api/performance/health');
        console.log('Health response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const health = await response.json();
        console.log('Received health:', health);
        
        updateHealthDisplay(health);
    } catch (error) {
        console.error('Failed to load system health:', error);
        // Show fallback health status
        const healthElement = document.getElementById('systemHealth');
        if (healthElement) {
            healthElement.innerHTML = '<div class="status-indicator status-error"></div><span>Health data unavailable</span>';
        }
    }
}

async function loadRecommendations() {
    try {
        console.log('Loading recommendations...');
        const response = await fetch('/admin/api/performance/recommendations');
        console.log('Recommendations response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('Received recommendations:', data);
        
        updateRecommendationsDisplay(data.recommendations || []);
    } catch (error) {
        console.error('Failed to load recommendations:', error);
        // Show fallback message
        const container = document.getElementById('recommendationsContainer');
        if (container) {
            container.innerHTML = '<div class="text-muted">Recommendations unavailable</div>';
        }
    }
}

async function loadPerformanceTrends() {
    try {
        const response = await fetch('/admin/api/performance/trends?hours=24');
        const trends = await response.json();
        
        if (response.ok && trends.time_series) {
            updateChartsDisplay(trends.time_series);
        } else if (trends.no_data) {
            showNoDataCharts();
        } else {
            console.warn('No trend data available');
        }
    } catch (error) {
        console.error('Error loading trends:', error);
        showNoDataCharts();
    }
}

function updateMetricsDisplay(metrics) {
    console.log('Received metrics data:', metrics);
    
    // Handle case where metrics might be nested or have different structure
    const data = metrics.metrics || metrics;
    console.log('Using metrics data:', data);
    
    // Safely update values with fallbacks
    const throughputValue = data.notification_throughput || data.throughput || 0;
    const connectionsValue = data.websocket_connections || data.connections || 0; // This field is missing from API
    const cacheHitRate = data.cache_hit_rate || data.cache_hit_rate_percent || 0;
    const memoryUsage = data.memory_usage_mb || data.memory_usage || 0;
    const cpuUsage = data.cpu_usage_percent || data.cpu_usage || 0;
    const dbQueryTime = data.database_query_time || data.db_query_time || 0;
    
    document.getElementById('throughputValue').textContent = throughputValue.toFixed ? throughputValue.toFixed(1) : throughputValue;
    document.getElementById('connectionsValue').textContent = connectionsValue;
    document.getElementById('cacheHitRateValue').textContent = (cacheHitRate * (cacheHitRate <= 1 ? 100 : 1)).toFixed(1) + '%';
    document.getElementById('memoryUsageValue').textContent = memoryUsage.toFixed ? memoryUsage.toFixed(1) : memoryUsage;
    document.getElementById('cpuUsageValue').textContent = (cpuUsage * (cpuUsage <= 1 ? 100 : 1)).toFixed(1) + '%';
    document.getElementById('dbQueryTimeValue').textContent = dbQueryTime.toFixed ? dbQueryTime.toFixed(1) : dbQueryTime;
    
    console.log('Updated metric values:', {
        throughput: throughputValue,
        connections: connectionsValue,
        cacheHitRate: cacheHitRate,
        memory: memoryUsage,
        cpu: cpuUsage,
        dbQuery: dbQueryTime
    });
    
    // Update detailed reports
    updateDetailedReports({
        throughput: throughputValue,
        connections: connectionsValue,
        cacheHitRate: cacheHitRate,
        memory: memoryUsage,
        cpu: cpuUsage,
        dbQuery: dbQueryTime
    });
    
    // Update metric card styles based on values
    updateMetricCardStyle('throughputValue', throughputValue, 50, 10);
    updateMetricCardStyle('connectionsValue', connectionsValue, 800, 500);
    updateMetricCardStyle('cacheHitRateValue', cacheHitRate, 0.7, 0.9);
    updateMetricCardStyle('memoryUsageValue', memoryUsage, 400, 300);
    updateMetricCardStyle('cpuUsageValue', cpuUsage, 80, 60);
    updateMetricCardStyle('dbQueryTimeValue', dbQueryTime, 100, 50);
}

function updateDetailedReports(metrics) {
    // Connection Pool Status
    const connectionPoolHtml = `
        <div class="mb-2">
            <strong>Active Connections:</strong> ${metrics.connections}
        </div>
        <div class="mb-2">
            <strong>Pool Utilization:</strong> ${((metrics.connections / 50) * 100).toFixed(1)}%
        </div>
        <div class="mb-2">
            <strong>Max Pool Size:</strong> 50
        </div>
        <div class="mb-2">
            <strong>Status:</strong> 
            <span class="badge ${metrics.connections > 40 ? 'bg-warning' : 'bg-success'}">
                ${metrics.connections > 40 ? 'High Usage' : 'Normal'}
            </span>
        </div>
    `;
    document.getElementById('connectionPoolStatus').innerHTML = connectionPoolHtml;
    
    // Cache Statistics
    const cacheStatsHtml = `
        <div class="mb-2">
            <strong>Hit Rate:</strong> ${(metrics.cacheHitRate * 100).toFixed(1)}%
        </div>
        <div class="mb-2">
            <strong>Miss Rate:</strong> ${((1 - metrics.cacheHitRate) * 100).toFixed(1)}%
        </div>
        <div class="mb-2">
            <strong>Cache Size:</strong> ${(metrics.memory * 0.1).toFixed(0)} MB
        </div>
        <div class="mb-2">
            <strong>Performance:</strong>
            <span class="badge ${metrics.cacheHitRate > 0.8 ? 'bg-success' : metrics.cacheHitRate > 0.6 ? 'bg-warning' : 'bg-danger'}">
                ${metrics.cacheHitRate > 0.8 ? 'Excellent' : metrics.cacheHitRate > 0.6 ? 'Good' : 'Poor'}
            </span>
        </div>
    `;
    document.getElementById('cacheStatistics').innerHTML = cacheStatsHtml;
    
    // Database Performance
    const dbPerfHtml = `
        <div class="mb-2">
            <strong>Query Time:</strong> ${metrics.dbQuery.toFixed(1)} ms
        </div>
        <div class="mb-2">
            <strong>Throughput:</strong> ${metrics.throughput.toFixed(1)} queries/sec
        </div>
        <div class="mb-2">
            <strong>CPU Impact:</strong> ${metrics.cpu.toFixed(1)}%
        </div>
        <div class="mb-2">
            <strong>Status:</strong>
            <span class="badge ${metrics.dbQuery < 50 ? 'bg-success' : metrics.dbQuery < 100 ? 'bg-warning' : 'bg-danger'}">
                ${metrics.dbQuery < 50 ? 'Fast' : metrics.dbQuery < 100 ? 'Moderate' : 'Slow'}
            </span>
        </div>
    `;
    document.getElementById('databasePerformance').innerHTML = dbPerfHtml;
}

function updateMetricCardStyle(elementId, value, criticalThreshold, warningThreshold) {
    const element = document.getElementById(elementId);
    if (!element) {
        console.warn(`Element with ID '${elementId}' not found`);
        return;
    }
    
    const card = element.closest('.card.stat-card');
    if (!card) {
        console.warn(`Card container not found for element '${elementId}'`);
        return;
    }
    
    card.classList.remove('warning', 'critical');
    
    if (value >= criticalThreshold) {
        card.classList.add('critical');
    } else if (value >= warningThreshold) {
        card.classList.add('warning');
    }
}

function updateHealthDisplay(health) {
    const healthElement = document.getElementById('systemHealth');
    const indicator = healthElement.querySelector('.status-indicator');
    const text = healthElement.querySelector('span');
    
    // Update indicator
    indicator.className = 'status-indicator';
    indicator.classList.add(`status-${health.overall_status}`);
    
    // Update text
    let statusText = `System Status: ${health.overall_status.toUpperCase()}`;
    if (health.alerts && health.alerts.length > 0) {
        statusText += ` (${health.alerts.length} alerts)`;
    }
    text.textContent = statusText;
}

function updateRecommendationsDisplay(recommendations) {
    const container = document.getElementById('recommendationsContainer');
    
    if (!recommendations || recommendations.length === 0) {
        container.innerHTML = '<div class="text-muted">No optimization recommendations at this time.</div>';
        return;
    }
    
    container.innerHTML = recommendations.map(rec => `
        <div class="recommendation-item ${rec.priority}-priority">
            <div class="d-flex justify-content-between align-items-start">
                <div>
                    <h6>${rec.title}</h6>
                    <p class="mb-2">${rec.description}</p>
                    <small class="text-muted">Priority: ${rec.priority}</small>
                </div>
                <button class="btn-optimize" onclick="applyRecommendation('${rec.action}', ${JSON.stringify(rec.parameters).replace(/"/g, '&quot;')})">
                    Apply
                </button>
            </div>
        </div>
    `).join('');
}

function updateChartsDisplay(timeSeries) {
    // Update throughput chart
    if (throughputChart && timeSeries.timestamps && timeSeries.throughput) {
        const labels = timeSeries.timestamps.map(ts => new Date(ts).toLocaleTimeString());
        
        throughputChart.data.labels = labels.slice(-20); // Last 20 data points
        throughputChart.data.datasets[0].data = timeSeries.throughput.slice(-20);
        throughputChart.update('none');
    }
    
    // Update resource chart
    if (resourceChart && timeSeries.timestamps) {
        const labels = timeSeries.timestamps.map(ts => new Date(ts).toLocaleTimeString());
        
        resourceChart.data.labels = labels.slice(-20);
        resourceChart.data.datasets[0].data = timeSeries.memory_usage.slice(-20);
        resourceChart.data.datasets[1].data = timeSeries.cpu_usage.slice(-20);
        resourceChart.update('none');
    }
}

function showNoDataCharts() {
    // Clear charts - plugin will show "No History Yet" text automatically
    if (throughputChart) {
        throughputChart.data.labels = [];
        throughputChart.data.datasets[0].data = [];
        throughputChart.resize();
        throughputChart.update('none');
    }
    
    if (resourceChart) {
        resourceChart.data.labels = [];
        resourceChart.data.datasets[0].data = [];
        resourceChart.data.datasets[1].data = [];
        resourceChart.resize();
        resourceChart.update('none');
    }
}

async function applyRecommendation(action, parameters) {
    try {
        const response = await fetch('/admin/api/performance/apply-recommendation', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                recommendation_id: action,
                parameters: { action, parameters }
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            showSuccess(result.message || 'Optimization applied successfully');
            // Refresh dashboard after applying optimization
            setTimeout(refreshDashboard, 2000);
        } else {
            showError(result.message || 'Failed to apply optimization');
        }
    } catch (error) {
        console.error('Error applying recommendation:', error);
        showError('Failed to apply optimization recommendation');
    }
}

}
</script>
{% endblock %}